## API Report File for "@cadl-lang/compiler"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { CompletionList } from 'vscode-languageserver/node.js';
import { CompletionParams } from 'vscode-languageserver/node.js';
import { DefinitionParams } from 'vscode-languageserver/node.js';
import { DidChangeWatchedFilesParams } from 'vscode-languageserver/node.js';
import { InitializedParams } from 'vscode-languageserver/node.js';
import { InitializeParams } from 'vscode-languageserver/node.js';
import { InitializeResult } from 'vscode-languageserver/node.js';
import { Location } from 'vscode-languageserver/node.js';
import { Parser } from 'prettier';
import { Printer } from 'prettier';
import { PublishDiagnosticsParams } from 'vscode-languageserver/node.js';
import { SupportLanguage } from 'prettier';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { TextDocumentChangeEvent } from 'vscode-languageserver/node.js';
import { WorkspaceFolder } from 'vscode-languageserver/node.js';
import { WorkspaceFoldersChangeEvent } from 'vscode-languageserver/node.js';

// @public (undocumented)
export function $doc({ program }: DecoratorContext, target: Type, text: string, sourceObject: Type): void;

// @public (undocumented)
export function $error({ program }: DecoratorContext, target: Type): void;

// @public (undocumented)
export function $format({ program }: DecoratorContext, target: Type, format: string): void;

// @public (undocumented)
export function $friendlyName({ program }: DecoratorContext, target: Type, friendlyName: string, sourceObject: Type | undefined): void;

// @public (undocumented)
export function $inspectType(program: Program, target: Type, text: string): void;

// @public (undocumented)
export function $inspectTypeName(program: Program, target: Type, text: string): void;

// @public (undocumented)
export function $intrinsic({ program }: DecoratorContext, target: Type, name: IntrinsicModelName): void;

// @public (undocumented)
export function $key({ program }: DecoratorContext, entity: Type, altName?: string): void;

// @public
export function $knownValues(context: DecoratorContext, target: Type, knownValues: Type): void;

// @public (undocumented)
export function $list({ program }: DecoratorContext, target: Type, listedType?: Type): void;

// @public (undocumented)
export function $maxLength({ program }: DecoratorContext, target: Type, maxLength: number): void;

// @public (undocumented)
export function $maxValue({ program }: DecoratorContext, target: Type, maxValue: number): void;

// @public (undocumented)
export function $minLength({ program }: DecoratorContext, target: Type, minLength: number): void;

// @public (undocumented)
export function $minValue({ program }: DecoratorContext, target: Type, minValue: number): void;

// @public (undocumented)
export function $numeric({ program }: DecoratorContext, target: Type): void;

// @public (undocumented)
export function $pattern({ program }: DecoratorContext, target: Type, pattern: string): void;

// @public (undocumented)
export function $secret({ program }: DecoratorContext, target: Type): void;

// @public (undocumented)
export function $serviceHost({ program }: DecoratorContext, target: Type, host: string): void;

// @public (undocumented)
export function $serviceTitle({ program }: DecoratorContext, target: Type, title: string): void;

// @public (undocumented)
export function $serviceVersion({ program }: DecoratorContext, target: Type, version: string): void;

// @public (undocumented)
export function $summary({ program }: DecoratorContext, target: Type, text: string, sourceObject: Type): void;

// @public (undocumented)
export function $tag({ program }: DecoratorContext, target: Type, tag: string): void;

// @public (undocumented)
export function $visibility({ program }: DecoratorContext, target: Type, ...visibilities: string[]): void;

// @public (undocumented)
export function $withOptionalProperties({ program }: DecoratorContext, target: Type): void;

// @public (undocumented)
export function $withoutDefaultValues({ program }: DecoratorContext, target: Type): void;

// @public (undocumented)
export function $withUpdateableProperties({ program }: DecoratorContext, target: Type): void;

// @public (undocumented)
export function $withVisibility({ program }: DecoratorContext, target: Type, ...visibilities: string[]): void;

// @public (undocumented)
export interface AliasStatementNode extends BaseNode, DeclarationNode, TemplateDeclarationNode {
    // (undocumented)
    readonly kind: SyntaxKind.AliasStatement;
    // (undocumented)
    readonly value: Expression;
}

// @public (undocumented)
export const altDirectorySeparator = "\\";

// @public (undocumented)
export interface ArrayExpressionNode extends BaseNode {
    // (undocumented)
    readonly elementType: Expression;
    // (undocumented)
    readonly kind: SyntaxKind.ArrayExpression;
}

// @public (undocumented)
export interface ArrayType extends BaseType {
    // (undocumented)
    elementType: Type;
    // (undocumented)
    kind: "Array";
    // (undocumented)
    node: ArrayExpressionNode;
}

// @public
export function assertType<TKind extends Type["kind"][]>(typeDescription: string, t: Type, ...kinds: TKind): asserts t is Type & {
    kind: TKind[number];
};

// @public (undocumented)
export interface BaseNode extends TextRange {
    // (undocumented)
    readonly directives?: readonly DirectiveExpressionNode[];
    // (undocumented)
    readonly flags: NodeFlags;
    // (undocumented)
    readonly kind: SyntaxKind;
    // (undocumented)
    parent?: Node;
    readonly symbol: Sym;
}

// @public (undocumented)
export interface BaseType {
    // (undocumented)
    instantiationParameters?: Type[];
    // (undocumented)
    kind: string;
    // (undocumented)
    node?: Node;
    // (undocumented)
    projectionBase?: Type;
    // (undocumented)
    get projections(): ProjectionStatementNode[];
    // (undocumented)
    projectionsByName(name: string): ProjectionStatementNode[];
    // (undocumented)
    projectionSource?: Type;
    // (undocumented)
    projector?: Projector;
}

// @public (undocumented)
export interface BlockComment extends TextRange {
    // (undocumented)
    kind: SyntaxKind.BlockComment;
}

// @public (undocumented)
export interface BooleanLiteralNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.BooleanLiteral;
    // (undocumented)
    readonly value: boolean;
}

// @public (undocumented)
export interface BooleanLiteralType extends BaseType {
    // (undocumented)
    kind: "Boolean";
    // (undocumented)
    node?: BooleanLiteralNode;
    // (undocumented)
    value: boolean;
}

// @public (undocumented)
export interface CadlLibrary<T extends {
    [code: string]: DiagnosticMessages;
}, E extends string = string> {
    // (undocumented)
    readonly diagnostics: DiagnosticMap<T>;
    // (undocumented)
    readonly emitter?: {
        names?: readonly E[];
    };
    // (undocumented)
    readonly name: string;
    // (undocumented)
    reportDiagnostic<C extends keyof T, M extends keyof T[C]>(program: Program, diag: DiagnosticReport<T, C, M>): void;
}

// @public
export interface CadlLibraryDef<T extends {
    [code: string]: DiagnosticMessages;
}, E extends string = string> {
    readonly diagnostics: DiagnosticMap<T>;
    readonly emitter?: {
        names?: readonly E[];
    };
    readonly name: string;
}

// Warning: (ae-forgotten-export) The symbol "formatter" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const CadlPrettierPlugin: typeof formatter;

// @public (undocumented)
export interface CadlScriptNode extends DeclarationNode, BaseNode {
    // (undocumented)
    readonly comments: readonly Comment[];
    // (undocumented)
    readonly file: SourceFile;
    // (undocumented)
    readonly inScopeNamespaces: readonly NamespaceStatementNode[];
    // (undocumented)
    readonly kind: SyntaxKind.CadlScript;
    // (undocumented)
    readonly locals: SymbolTable;
    // (undocumented)
    readonly namespaces: NamespaceStatementNode[];
    // (undocumented)
    readonly parseDiagnostics: readonly Diagnostic[];
    // (undocumented)
    readonly printable: boolean;
    // (undocumented)
    readonly statements: readonly Statement[];
    // (undocumented)
    readonly usings: readonly UsingStatementNode[];
}

// @public
export function cadlTypeToJson<T>(cadlType: CadlValue, target: DiagnosticTarget): [T | undefined, Diagnostic[]];

// @public (undocumented)
export type CadlValue = Type | string | number | boolean;

// @public (undocumented)
export const cadlVersion: string;

// @public (undocumented)
export interface CallableMessage<T extends string[]> {
    // (undocumented)
    (dict: Record<T[number], string>): string;
    // (undocumented)
    keys: T;
}

// @public (undocumented)
export function checkIfServiceNamespace(program: Program, namespace: NamespaceType): boolean;

// @public (undocumented)
export type Comment = LineComment | BlockComment;

// Warning: (ae-forgotten-export) The symbol "CompilerOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function compile(mainFile: string, host: CompilerHost, options?: CompilerOptions): Promise<Program>;

// @public
export function compilerAssert(condition: any, message: string, target?: DiagnosticTarget): asserts condition;

// @public (undocumented)
export interface CompilerHost {
    // (undocumented)
    fileURLToPath(url: string): string;
    // (undocumented)
    getExecutionRoot(): string;
    // (undocumented)
    getJsImport(path: string): Promise<Record<string, any>>;
    // (undocumented)
    getLibDirs(): string[];
    // (undocumented)
    logSink: LogSink;
    mkdirp(path: string): Promise<string | undefined>;
    // (undocumented)
    pathToFileURL(path: string): string;
    readDir(dir: string): Promise<string[]>;
    // (undocumented)
    readFile(path: string): Promise<SourceFile>;
    // (undocumented)
    readUrl(url: string): Promise<SourceFile>;
    // (undocumented)
    realpath(path: string): Promise<string>;
    removeDir(dir: string, options?: RemoveDirOptions): Promise<void>;
    // (undocumented)
    stat(path: string): Promise<{
        isDirectory(): boolean;
        isFile(): boolean;
    }>;
    writeFile(path: string, content: string): Promise<void>;
}

// @public
export function createCadlLibrary<T extends {
    [code: string]: DiagnosticMessages;
}, E extends string>(lib: Readonly<CadlLibraryDef<T, E>>): CadlLibrary<T, E>;

// @public
export function createDiagnosticCreator<T extends {
    [code: string]: DiagnosticMessages;
}>(diagnostics: DiagnosticMap<T>, libraryName?: string): DiagnosticCreator<T>;

// @public (undocumented)
export function createProgram(host: CompilerHost, mainFile: string, options?: CompilerOptions): Promise<Program>;

// @public (undocumented)
export function createScanner(source: string | SourceFile, diagnosticHandler: DiagnosticHandler): Scanner;

// @public (undocumented)
export function createServer(host: ServerHost): Server;

// @public (undocumented)
export function createSourceFile(text: string, path: string): SourceFile;

// @public (undocumented)
export type Declaration = ModelStatementNode | InterfaceStatementNode | UnionStatementNode | NamespaceStatementNode | OperationStatementNode | TemplateParameterDeclarationNode | ProjectionStatementNode | ProjectionParameterDeclarationNode | ProjectionLambdaParameterDeclarationNode | EnumStatementNode | AliasStatementNode;

// @public (undocumented)
export interface DeclarationNode {
    // (undocumented)
    id: IdentifierNode;
}

// @public (undocumented)
export interface DecoratedType {
    // (undocumented)
    decorators: DecoratorApplication[];
}

// @public (undocumented)
export interface DecoratorApplication {
    // (undocumented)
    args: DecoratorArgument[];
    // (undocumented)
    decorator: DecoratorFunction;
    // (undocumented)
    node?: DecoratorExpressionNode;
}

// @public
export type DecoratorArgument = Type | number | string | boolean;

// @public (undocumented)
export interface DecoratorContext {
    // (undocumented)
    program: Program;
}

// @public (undocumented)
export interface DecoratorExpressionNode extends BaseNode {
    // (undocumented)
    readonly arguments: readonly Expression[];
    // (undocumented)
    readonly kind: SyntaxKind.DecoratorExpression;
    // (undocumented)
    readonly target: IdentifierNode | MemberExpressionNode;
}

// @public (undocumented)
export interface DecoratorFunction {
    // (undocumented)
    (program: DecoratorContext, target: Type, ...customArgs: any[]): void;
    // (undocumented)
    namespace?: string;
}

// @public (undocumented)
const defaultOptions: {};

// @public (undocumented)
export interface Diagnostic {
    // (undocumented)
    code: string;
    // (undocumented)
    message: string;
    // (undocumented)
    severity: DiagnosticSeverity;
    // (undocumented)
    target: DiagnosticTarget | typeof NoTarget;
}

// @public (undocumented)
export interface DiagnosticCreator<T extends {
    [code: string]: DiagnosticMessages;
}> {
    // (undocumented)
    createDiagnostic<C extends keyof T, M extends keyof T[C] = "default">(diag: DiagnosticReport<T, C, M>): Diagnostic;
    // (undocumented)
    readonly diagnostics: DiagnosticMap<T>;
    // (undocumented)
    reportDiagnostic<C extends keyof T, M extends keyof T[C] = "default">(program: Program, diag: DiagnosticReport<T, C, M>): void;
    // (undocumented)
    readonly type: T;
}

// @public (undocumented)
export interface DiagnosticDefinition<M extends DiagnosticMessages> {
    // (undocumented)
    readonly messages: M;
    // (undocumented)
    readonly severity: "warning" | "error";
}

// @public (undocumented)
export type DiagnosticFormat<T extends {
    [code: string]: DiagnosticMessages;
}, C extends keyof T, M extends keyof T[C] = "default"> = T[C][M] extends CallableMessage<infer A> ? {
    format: Record<A[number], string>;
} : Record<string, unknown>;

// @public (undocumented)
export type DiagnosticHandler = (diagnostic: Diagnostic) => void;

// @public (undocumented)
export type DiagnosticMap<T extends {
    [code: string]: DiagnosticMessages;
}> = {
    readonly [code in keyof T]: DiagnosticDefinition<T[code]>;
};

// @public (undocumented)
export interface DiagnosticMessages {
    // (undocumented)
    readonly [messageId: string]: string | CallableMessage<string[]>;
}

// @public (undocumented)
export type DiagnosticReport<T extends {
    [code: string]: DiagnosticMessages;
}, C extends keyof T, M extends keyof T[C] = "default"> = {
    code: C;
    messageId?: M;
    target: DiagnosticTarget | typeof NoTarget;
} & DiagnosticFormat<T, C, M>;

// @public (undocumented)
export type DiagnosticSeverity = "error" | "warning";

// @public (undocumented)
export type DiagnosticTarget = Node | Type | Sym | SourceLocation;

// @public (undocumented)
export type Directive = SuppressDirective;

// @public (undocumented)
export type DirectiveArgument = StringLiteralNode | IdentifierNode;

// @public (undocumented)
export interface DirectiveBase {
    // (undocumented)
    node: DirectiveExpressionNode;
}

// @public (undocumented)
export interface DirectiveExpressionNode extends BaseNode {
    // (undocumented)
    readonly arguments: readonly DirectiveArgument[];
    // (undocumented)
    readonly kind: SyntaxKind.DirectiveExpression;
    // (undocumented)
    readonly target: IdentifierNode;
}

// @public
export const directorySeparator = "/";

// @public (undocumented)
export interface Dirent {
    // (undocumented)
    isDirectory(): boolean;
    // (undocumented)
    isFile(): boolean;
    // (undocumented)
    name: string;
}

// @public (undocumented)
export interface EmitOptions<E extends string> {
    // (undocumented)
    name?: E;
}

// @public
export type EmitOptionsFor<C> = C extends CadlLibrary<infer _T, infer E> ? EmitOptions<E> : never;

// @public (undocumented)
export type Emitter = (program: Program, options: EmitterOptions) => void;

// @public (undocumented)
export type EmitterOptions = {
    name?: string;
} & Record<string, any>;

// @public (undocumented)
export interface EmptyStatementNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.EmptyStatement;
}

// @public (undocumented)
export function ensureTrailingDirectorySeparator(path: string): string;

// @public (undocumented)
export interface EnumMemberNode extends BaseNode {
    // (undocumented)
    readonly decorators: readonly DecoratorExpressionNode[];
    // (undocumented)
    readonly id: IdentifierNode | StringLiteralNode;
    // (undocumented)
    readonly kind: SyntaxKind.EnumMember;
    // (undocumented)
    readonly value?: StringLiteralNode | NumericLiteralNode;
}

// @public (undocumented)
export interface EnumMemberType extends BaseType, DecoratedType {
    // (undocumented)
    enum: EnumType;
    // (undocumented)
    kind: "EnumMember";
    // (undocumented)
    name: string;
    // (undocumented)
    node: EnumMemberNode;
    // (undocumented)
    value?: string | number;
}

// @public (undocumented)
export interface EnumStatementNode extends BaseNode, DeclarationNode {
    // (undocumented)
    readonly decorators: readonly DecoratorExpressionNode[];
    // (undocumented)
    readonly kind: SyntaxKind.EnumStatement;
    // (undocumented)
    readonly members: readonly EnumMemberNode[];
}

// @public (undocumented)
export interface EnumType extends BaseType, DecoratedType {
    // (undocumented)
    kind: "Enum";
    // (undocumented)
    members: EnumMemberType[];
    // (undocumented)
    name: string;
    // (undocumented)
    namespace?: NamespaceType;
    // (undocumented)
    node: EnumStatementNode;
}

// @public (undocumented)
export interface ErrorType extends IntrinsicType {
    // (undocumented)
    name: "ErrorType";
}

// @public (undocumented)
export class EventEmitter<T extends {
    [key: string]: (...args: any) => any;
}> {
    // (undocumented)
    emit<K extends keyof T>(name: K, ...args: Parameters<T[K]>): void;
    // (undocumented)
    on<K extends keyof T>(name: K, listener: (...args: Parameters<T[K]>) => any): void;
}

// @public (undocumented)
export type Expression = ArrayExpressionNode | MemberExpressionNode | ModelExpressionNode | TupleExpressionNode | UnionExpressionNode | IntersectionExpressionNode | TypeReferenceNode | IdentifierNode | StringLiteralNode | NumericLiteralNode | BooleanLiteralNode | VoidKeywordNode | NeverKeywordNode;

// @public (undocumented)
export function formatDiagnostic(diagnostic: Diagnostic): string;

// @public (undocumented)
export interface FunctionType extends BaseType {
    // (undocumented)
    call(...args: any[]): Type;
    // (undocumented)
    kind: "Function";
}

// @public (undocumented)
export function getAllTags(program: Program, target: NamespaceType | InterfaceType | OperationType): string[] | undefined;

// @public
export function getAnyExtensionFromPath(path: string): string;

// @public
export function getAnyExtensionFromPath(path: string, extensions: string | readonly string[], ignoreCase: boolean): string;

// @public
export function getBaseFileName(path: string): string;

// @public
export function getBaseFileName(path: string, extensions: string | readonly string[], ignoreCase: boolean): string;

// @public (undocumented)
export function getDirectoryPath(path: string): string;

// @public (undocumented)
export function getDoc(program: Program, target: Type): string | undefined;

// @public (undocumented)
export function getFormat(program: Program, target: Type): string | undefined;

// @public (undocumented)
export function getFriendlyName(program: Program, target: Type): string;

// @public
export function getIntrinsicModelName(program: Program, target: Type): IntrinsicModelName;

// @public (undocumented)
export function getKeyName(program: Program, property: ModelTypeProperty): string;

// @public (undocumented)
export function getKnownValues(program: Program, target: ModelType | ModelTypeProperty): EnumType | undefined;

// @public (undocumented)
export function getListOperationType(program: Program, target: Type): ModelType | undefined;

// @public (undocumented)
export function getMaxLength(program: Program, target: Type): number | undefined;

// @public (undocumented)
export function getMaxValue(program: Program, target: Type): number | undefined;

// @public (undocumented)
export function getMinLength(program: Program, target: Type): number | undefined;

// @public (undocumented)
export function getMinValue(program: Program, target: Type): number | undefined;

// @public (undocumented)
export function getNodeAtPosition(script: CadlScriptNode, position: number, filter?: (node: Node) => boolean): Node | undefined;

// @public (undocumented)
export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string;

// @public (undocumented)
export function getNormalizedAbsolutePathWithoutRoot(fileName: string, currentDirectory: string | undefined): string;

// @public
export function getNormalizedPathComponents(path: string, currentDirectory: string | undefined): string[];

// @public
export function getPathComponents(path: string, currentDirectory?: string): string[];

// @public
export function getPathFromPathComponents(pathComponents: readonly string[]): string;

// @public (undocumented)
export function getPattern(program: Program, target: Type): string | undefined;

// @public (undocumented)
export function getProperty(type: ModelType, propertyName: string): ModelTypeProperty | undefined;

// @public
export function getPropertyType(target: ModelType | ModelTypeProperty): Type;

// @public
export function getRootLength(path: string): number;

// @public (undocumented)
export function getServiceHost(program: Program): string | undefined;

// @public (undocumented)
export function getServiceNamespace(program: Program): NamespaceType | undefined;

// @public (undocumented)
export function getServiceNamespaceString(program: Program): string | undefined;

// @public (undocumented)
export function getServiceTitle(program: Program): string;

// @public (undocumented)
export function getServiceVersion(program: Program): string;

// @public (undocumented)
export function getSourceLocation(target: DiagnosticTarget): SourceLocation;

// @public (undocumented)
export function getSourceLocation(target: typeof NoTarget | undefined): undefined;

// @public (undocumented)
export function getSourceLocation(target: DiagnosticTarget | typeof NoTarget | undefined): SourceLocation | undefined;

// @public (undocumented)
export function getSummary(program: Program, type: Type): string | undefined;

// @public (undocumented)
export function getTags(program: Program, target: Type): string[];

// @public (undocumented)
export function getVisibility(program: Program, target: Type): string[] | undefined;

// @public (undocumented)
export function hasParseError(node: Node): number | true;

// @public
export function hasTrailingDirectorySeparator(path: string): boolean;

// @public (undocumented)
export interface IdentifierNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.Identifier;
    // (undocumented)
    readonly sv: string;
}

// @public (undocumented)
export interface ImportStatementNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ImportStatement;
    // (undocumented)
    readonly path: StringLiteralNode;
}

// @public (undocumented)
export type InferredCadlValue<K extends Type["kind"]> = K extends "String" ? string : K extends "Number" ? number : K extends "Boolean" ? boolean : Type & {
    kind: K;
};

// @public (undocumented)
export interface InterfaceStatementNode extends BaseNode, DeclarationNode, TemplateDeclarationNode {
    // (undocumented)
    readonly decorators: readonly DecoratorExpressionNode[];
    // (undocumented)
    readonly kind: SyntaxKind.InterfaceStatement;
    // (undocumented)
    readonly mixes: readonly TypeReferenceNode[];
    // (undocumented)
    readonly operations: readonly OperationStatementNode[];
}

// @public (undocumented)
export interface InterfaceType extends BaseType, DecoratedType, TemplatedType {
    // (undocumented)
    kind: "Interface";
    // (undocumented)
    name: string;
    // (undocumented)
    namespace?: NamespaceType;
    // (undocumented)
    node: InterfaceStatementNode;
    // (undocumented)
    operations: Map<string, OperationType>;
}

// @public (undocumented)
export interface IntersectionExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.IntersectionExpression;
    // (undocumented)
    readonly options: readonly Expression[];
}

// @public (undocumented)
export type IntrinsicModel<T extends IntrinsicModelName = IntrinsicModelName> = ModelType & {
    name: T;
};

// @public (undocumented)
export type IntrinsicModelName = "bytes" | "int64" | "int32" | "int16" | "int8" | "uint64" | "uint32" | "uint16" | "uint8" | "safeint" | "float32" | "float64" | "string" | "plainDate" | "plainTime" | "zonedDateTime" | "duration" | "boolean" | "null" | "Map";

// @public (undocumented)
export interface IntrinsicType extends BaseType {
    // (undocumented)
    kind: "Intrinsic";
    // (undocumented)
    name: "ErrorType" | "void" | "never";
}

// @public (undocumented)
export interface InvalidStatementNode extends BaseNode {
    // (undocumented)
    readonly decorators: readonly DecoratorExpressionNode[];
    // (undocumented)
    readonly kind: SyntaxKind.InvalidStatement;
}

// @public
export function isAnyDirectorySeparator(charCode: number): boolean;

// @public
export function isCadlValueTypeOf<K extends Type["kind"]>(target: CadlValue, expectedType: K | K[]): target is InferredCadlValue<K>;

// @public (undocumented)
export function isComment(token: Token): boolean;

// @public (undocumented)
export function isErrorModel(program: Program, target: Type): boolean;

// @public (undocumented)
export function isErrorType(type: Type): boolean;

// @public (undocumented)
export function isImportStatement(node: Node): node is ImportStatementNode;

// @public (undocumented)
export function isIntrinsic(program: Program, target: Type | undefined): boolean;

// @public (undocumented)
export function isKey(program: Program, property: ModelTypeProperty): boolean;

// @public (undocumented)
export function isKeyword(token: Token): boolean;

// @public (undocumented)
export function isListOperation(program: Program, target: OperationType): boolean;

// @public (undocumented)
export function isLiteral(token: Token): boolean;

// @public (undocumented)
export function isNumericType(program: Program, target: Type): boolean;

// @public (undocumented)
export function isPathAbsolute(path: string): boolean;

// @public (undocumented)
export function isPunctuation(token: Token): boolean;

// @public (undocumented)
export function isSecret(program: Program, target: Type): boolean | undefined;

// @public (undocumented)
export function isStatementKeyword(token: Token): boolean;

// @public (undocumented)
export function isStringType(program: Program, target: Type): boolean;

// @public
export function isTemplate(model: ModelType): boolean;

// @public (undocumented)
export function isTrivia(token: Token): boolean;

// @public
export function isUrl(path: string): boolean;

// @public (undocumented)
export function isVoidType(type: Type): type is VoidType;

// @public
export function joinPaths(path: string, ...paths: (string | undefined)[]): string;

// @public (undocumented)
export interface JsSourceFileNode extends DeclarationNode, BaseNode {
    // (undocumented)
    readonly esmExports: any;
    // (undocumented)
    readonly file: SourceFile;
    // (undocumented)
    readonly kind: SyntaxKind.JsSourceFile;
    // (undocumented)
    readonly namespaceSymbols: Sym[];
}

// @public (undocumented)
const languages: SupportLanguage[];

// @public
export interface LineAndCharacter {
    character: number;
    line: number;
}

// @public (undocumented)
export interface LineComment extends TextRange {
    // (undocumented)
    kind: SyntaxKind.LineComment;
}

// @public (undocumented)
export type LiteralNode = StringLiteralNode | NumericLiteralNode | BooleanLiteralNode;

// @public (undocumented)
export type LiteralType = StringLiteralType | NumericLiteralType | BooleanLiteralType;

// @public (undocumented)
export function logDiagnostics(diagnostics: readonly Diagnostic[], logger: LogSink): void;

// @public (undocumented)
export interface Logger {
    // (undocumented)
    debug(message: string): void;
    // (undocumented)
    error(message: string): void;
    // (undocumented)
    info(message: string): void;
    // (undocumented)
    log(log: LogInfo): void;
    // (undocumented)
    verbose(message: string): void;
    // (undocumented)
    warn(message: string): void;
}

// @public (undocumented)
export interface LogInfo {
    // (undocumented)
    code?: string;
    // (undocumented)
    level: LogLevel;
    // (undocumented)
    message: string;
    // (undocumented)
    target?: DiagnosticTarget | typeof NoTarget;
}

// @public (undocumented)
export type LogLevel = "debug" | "verbose" | "info" | "warning" | "error";

// @public (undocumented)
export interface LogSink {
    // (undocumented)
    log(log: ProcessedLog): void;
}

// @public
export function logVerboseTestOutput(messageOrCallback: string | ((log: (message: string) => void) => void)): void;

// @public (undocumented)
export interface MemberExpressionNode extends BaseNode {
    // (undocumented)
    readonly base: MemberExpressionNode | IdentifierNode;
    // (undocumented)
    readonly id: IdentifierNode;
    // (undocumented)
    readonly kind: SyntaxKind.MemberExpression;
}

// @public (undocumented)
export interface ModelExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ModelExpression;
    // (undocumented)
    readonly properties: (ModelPropertyNode | ModelSpreadPropertyNode)[];
}

// @public (undocumented)
export interface ModelPropertyNode extends BaseNode {
    // (undocumented)
    readonly decorators: readonly DecoratorExpressionNode[];
    // (undocumented)
    readonly default?: Expression;
    // (undocumented)
    readonly id: IdentifierNode | StringLiteralNode;
    // (undocumented)
    readonly kind: SyntaxKind.ModelProperty;
    // (undocumented)
    readonly optional: boolean;
    // (undocumented)
    readonly value: Expression;
}

// @public (undocumented)
export interface ModelSpreadPropertyNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ModelSpreadProperty;
    // (undocumented)
    readonly target: TypeReferenceNode;
}

// @public (undocumented)
export interface ModelStatementNode extends BaseNode, DeclarationNode, TemplateDeclarationNode {
    // (undocumented)
    readonly decorators: DecoratorExpressionNode[];
    // (undocumented)
    readonly extends?: TypeReferenceNode;
    // (undocumented)
    readonly is?: TypeReferenceNode;
    // (undocumented)
    readonly kind: SyntaxKind.ModelStatement;
    // (undocumented)
    readonly properties: readonly (ModelPropertyNode | ModelSpreadPropertyNode)[];
}

// @public (undocumented)
export interface ModelType extends BaseType, DecoratedType, TemplatedType {
    baseModel?: ModelType;
    derivedModels: ModelType[];
    // (undocumented)
    kind: "Model";
    // (undocumented)
    name: IntrinsicModelName | string;
    // (undocumented)
    namespace?: NamespaceType;
    // (undocumented)
    node: ModelStatementNode | ModelExpressionNode | IntersectionExpressionNode | ProjectionModelExpressionNode;
    // (undocumented)
    properties: Map<string, ModelTypeProperty>;
}

// @public (undocumented)
export interface ModelTypeProperty extends BaseType, DecoratedType {
    // (undocumented)
    default?: Type;
    // (undocumented)
    kind: "ModelProperty";
    // (undocumented)
    model?: ModelType;
    // (undocumented)
    name: string;
    // (undocumented)
    node: ModelPropertyNode | ModelSpreadPropertyNode | ProjectionModelPropertyNode | ProjectionModelSpreadPropertyNode;
    // (undocumented)
    optional: boolean;
    // (undocumented)
    sourceProperty?: ModelTypeProperty;
    // (undocumented)
    type: Type;
}

// @public (undocumented)
export const namespace = "Cadl";

// @public (undocumented)
export interface NamespaceStatementNode extends BaseNode, DeclarationNode {
    // (undocumented)
    readonly decorators: DecoratorExpressionNode[];
    // (undocumented)
    readonly id: IdentifierNode;
    // (undocumented)
    readonly kind: SyntaxKind.NamespaceStatement;
    // (undocumented)
    readonly locals?: SymbolTable;
    // (undocumented)
    readonly statements?: readonly Statement[] | NamespaceStatementNode;
}

// @public (undocumented)
export interface NamespaceType extends BaseType, DecoratedType {
    // (undocumented)
    enums: Map<string, EnumType>;
    // (undocumented)
    interfaces: Map<string, InterfaceType>;
    // (undocumented)
    kind: "Namespace";
    // (undocumented)
    models: Map<string, ModelType>;
    // (undocumented)
    name: string;
    // (undocumented)
    namespace?: NamespaceType;
    // (undocumented)
    namespaces: Map<string, NamespaceType>;
    // (undocumented)
    node: NamespaceStatementNode;
    // (undocumented)
    operations: Map<string, OperationType>;
    // (undocumented)
    unions: Map<string, UnionType>;
}

// @public (undocumented)
export function navigateProgram(program: Program, listeners: EventEmitter<SemanticNodeListener> | SemanticNodeListener): void;

// @public (undocumented)
export interface NeverKeywordNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.NeverKeyword;
}

// @public (undocumented)
export interface NeverType extends IntrinsicType {
    // (undocumented)
    name: "never";
}

// @public (undocumented)
export type Node = CadlScriptNode | JsSourceFileNode | TemplateParameterDeclarationNode | ProjectionParameterDeclarationNode | ProjectionLambdaParameterDeclarationNode | ModelPropertyNode | UnionVariantNode | OperationStatementNode | EnumMemberNode | ModelSpreadPropertyNode | DecoratorExpressionNode | DirectiveExpressionNode | Statement | Expression | ProjectionStatementItem | ProjectionExpression | ProjectionModelSelectorNode | ProjectionInterfaceSelectorNode | ProjectionOperationSelectorNode | ProjectionEnumSelectorNode | ProjectionUnionSelectorNode | ProjectionModelPropertyNode | ProjectionModelSpreadPropertyNode | ProjectionStatementNode | ProjectionNode;

// @public (undocumented)
export const enum NodeFlags {
    DescendantErrorsExamined = 1,
    DescendantHasError = 4,
    // (undocumented)
    None = 0,
    Synthetic = 8,
    ThisNodeHasError = 2
}

// @public
export const NodeHost: CompilerHost;

// @public (undocumented)
export function normalizePath(path: string): string;

// @public
export function normalizeSlashes(path: string): string;

// @public (undocumented)
export const NoTarget: unique symbol;

// @public (undocumented)
export interface NumericLiteralNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.NumericLiteral;
    // (undocumented)
    readonly value: number;
}

// @public (undocumented)
export interface NumericLiteralType extends BaseType {
    // (undocumented)
    kind: "Number";
    // (undocumented)
    node?: NumericLiteralNode;
    // (undocumented)
    value: number;
}

// @public (undocumented)
export interface ObjectType extends BaseType {
    // (undocumented)
    kind: "Object";
    // (undocumented)
    properties: Record<string, Type>;
}

// @public (undocumented)
export interface OperationStatementNode extends BaseNode, DeclarationNode {
    // (undocumented)
    readonly decorators: readonly DecoratorExpressionNode[];
    // (undocumented)
    readonly kind: SyntaxKind.OperationStatement;
    // (undocumented)
    readonly parameters: ModelExpressionNode;
    // (undocumented)
    readonly returnType: Expression;
}

// @public (undocumented)
export interface OperationType extends BaseType, DecoratedType {
    // (undocumented)
    interface?: InterfaceType;
    // (undocumented)
    kind: "Operation";
    // (undocumented)
    name: string;
    // (undocumented)
    namespace?: NamespaceType;
    // (undocumented)
    node: OperationStatementNode;
    // (undocumented)
    parameters: ModelType;
    // (undocumented)
    returnType: Type;
}

// @public (undocumented)
export function paramMessage<T extends string[]>(strings: readonly string[], ...keys: T): CallableMessage<T>;

// @public (undocumented)
export function parse(code: string | SourceFile, options?: ParseOptions): CadlScriptNode;

// @public (undocumented)
export interface ParseOptions {
    comments?: boolean;
}

// @public (undocumented)
const parsers: {
    cadl: Parser<any>;
};

// @public (undocumented)
const printers: {
    "cadl-format": Printer<Node>;
};

// @public (undocumented)
export interface ProcessedLog {
    // (undocumented)
    code?: string;
    // (undocumented)
    level: LogLevel;
    // (undocumented)
    message: string;
    // (undocumented)
    sourceLocation?: SourceLocation;
}

// @public (undocumented)
export interface Program {
    // Warning: (ae-forgotten-export) The symbol "Checker" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    checker?: Checker;
    // (undocumented)
    compilerOptions: CompilerOptions;
    // (undocumented)
    currentProjector?: Projector;
    // (undocumented)
    readonly diagnostics: readonly Diagnostic[];
    // (undocumented)
    disableProjections(): void;
    // Warning: (ae-forgotten-export) The symbol "EmitterRef" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    emitters: EmitterRef[];
    // (undocumented)
    enableProjections(projections: ProjectionApplication[], startNode?: Type): Projector;
    // (undocumented)
    evalCadlScript(cadlScript: string): void;
    // (undocumented)
    getOption(key: string): string | undefined;
    // (undocumented)
    hasError(): boolean;
    // (undocumented)
    host: CompilerHost;
    // (undocumented)
    jsSourceFiles: Map<string, JsSourceFileNode>;
    // (undocumented)
    literalTypes: Map<string | number | boolean, LiteralType>;
    // (undocumented)
    loadCadlScript(cadlScript: SourceFile): Promise<CadlScriptNode>;
    // (undocumented)
    logger: Logger;
    // (undocumented)
    mainFile?: CadlScriptNode;
    // (undocumented)
    onValidate(cb: (program: Program) => void | Promise<void>): void;
    // (undocumented)
    reportDiagnostic(diagnostic: Diagnostic): void;
    // (undocumented)
    reportDiagnostics(diagnostics: readonly Diagnostic[]): void;
    // (undocumented)
    reportDuplicateSymbols(symbols: SymbolTable | undefined): void;
    sourceFiles: Map<string, CadlScriptNode>;
    // (undocumented)
    stateMap(key: symbol): Map<Type, any>;
    // (undocumented)
    stateMaps: Map<symbol, Map<Type, any>>;
    // (undocumented)
    stateSet(key: symbol): Set<Type>;
    // (undocumented)
    stateSets: Map<symbol, Set<Type>>;
}

// @public (undocumented)
export interface ProjectionApplication {
    // (undocumented)
    arguments: DecoratorArgument[];
    // (undocumented)
    direction?: "from" | "to";
    // (undocumented)
    projectionName: string;
    // (undocumented)
    scope?: Type;
}

// @public (undocumented)
export interface ProjectionArithmeticExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionArithmeticExpression;
    // (undocumented)
    readonly left: ProjectionExpression;
    // (undocumented)
    readonly op: "+" | "-" | "*" | "/";
    // (undocumented)
    readonly right: ProjectionExpression;
}

// @public (undocumented)
export interface ProjectionBlockExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionBlockExpression;
    // (undocumented)
    readonly statements: ProjectionStatementItem[];
}

// @public (undocumented)
export interface ProjectionCallExpressionNode extends BaseNode {
    // (undocumented)
    readonly arguments: ProjectionExpression[];
    // (undocumented)
    readonly callKind: "method" | "template";
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionCallExpression;
    // (undocumented)
    readonly target: ProjectionExpression;
}

// @public (undocumented)
export interface ProjectionDecoratorReferenceExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionDecoratorReferenceExpression;
    // (undocumented)
    readonly target: MemberExpressionNode | IdentifierNode;
}

// @public (undocumented)
export interface ProjectionEnumSelectorNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionEnumSelector;
}

// @public (undocumented)
export interface ProjectionEqualityExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionEqualityExpression;
    // (undocumented)
    readonly left: ProjectionExpression;
    // (undocumented)
    readonly op: "==" | "!=";
    // (undocumented)
    readonly right: ProjectionExpression;
}

// @public
export class ProjectionError extends Error {
    constructor(message: string);
}

// @public (undocumented)
export type ProjectionExpression = ProjectionLogicalExpressionNode | ProjectionRelationalExpressionNode | ProjectionEqualityExpressionNode | ProjectionUnaryExpressionNode | ProjectionArithmeticExpressionNode | ProjectionCallExpressionNode | ProjectionMemberExpressionNode | ProjectionDecoratorReferenceExpressionNode | ProjectionTupleExpressionNode | ProjectionModelExpressionNode | ProjectionIfExpressionNode | ProjectionBlockExpressionNode | ProjectionLambdaExpressionNode | StringLiteralNode | NumericLiteralNode | BooleanLiteralNode | IdentifierNode | VoidKeywordNode | NeverKeywordNode | ReturnExpressionNode;

// @public (undocumented)
export interface ProjectionExpressionStatement extends BaseNode {
    // (undocumented)
    readonly expr: ProjectionExpression;
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionExpressionStatement;
}

// @public (undocumented)
export interface ProjectionIfExpressionNode extends BaseNode {
    // (undocumented)
    readonly alternate?: ProjectionBlockExpressionNode | ProjectionIfExpressionNode;
    // (undocumented)
    readonly consequent: ProjectionBlockExpressionNode;
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionIfExpression;
    // (undocumented)
    readonly test: ProjectionExpression;
}

// @public (undocumented)
export interface ProjectionInterfaceSelectorNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionInterfaceSelector;
}

// @public (undocumented)
export interface ProjectionLambdaExpressionNode extends BaseNode {
    // (undocumented)
    readonly body: ProjectionBlockExpressionNode;
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionLambdaExpression;
    // (undocumented)
    readonly locals?: SymbolTable;
    // (undocumented)
    readonly parameters: ProjectionLambdaParameterDeclarationNode[];
}

// @public (undocumented)
export interface ProjectionLambdaParameterDeclarationNode extends DeclarationNode, BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionLambdaParameterDeclaration;
}

// @public (undocumented)
export interface ProjectionLogicalExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionLogicalExpression;
    // (undocumented)
    readonly left: ProjectionExpression;
    // (undocumented)
    readonly op: "||" | "&&";
    // (undocumented)
    readonly right: ProjectionExpression;
}

// @public (undocumented)
export interface ProjectionMemberExpressionNode extends BaseNode {
    // (undocumented)
    readonly base: ProjectionExpression;
    // (undocumented)
    readonly id: IdentifierNode;
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionMemberExpression;
    // (undocumented)
    readonly selector: "." | "::";
}

// @public (undocumented)
export interface ProjectionModelExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionModelExpression;
    // (undocumented)
    readonly properties: (ProjectionModelPropertyNode | ProjectionModelSpreadPropertyNode)[];
}

// @public (undocumented)
export interface ProjectionModelPropertyNode extends BaseNode {
    // (undocumented)
    readonly decorators: DecoratorExpressionNode[];
    // (undocumented)
    readonly default?: ProjectionExpression;
    // (undocumented)
    readonly id: IdentifierNode | StringLiteralNode;
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionModelProperty;
    // (undocumented)
    readonly optional: boolean;
    // (undocumented)
    readonly value: ProjectionExpression;
}

// @public (undocumented)
export interface ProjectionModelSelectorNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionModelSelector;
}

// @public (undocumented)
export interface ProjectionModelSpreadPropertyNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionModelSpreadProperty;
    // (undocumented)
    readonly target: ProjectionExpression;
}

// @public (undocumented)
export interface ProjectionNode extends BaseNode {
    // (undocumented)
    readonly body: ProjectionStatementItem[];
    // (undocumented)
    readonly direction: "to" | "from";
    // (undocumented)
    readonly kind: SyntaxKind.Projection;
    // (undocumented)
    readonly locals?: SymbolTable;
    // (undocumented)
    readonly parameters: ProjectionParameterDeclarationNode[];
}

// @public (undocumented)
export interface ProjectionOperationSelectorNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionOperationSelector;
}

// @public (undocumented)
export interface ProjectionParameterDeclarationNode extends DeclarationNode, BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionParameterDeclaration;
}

// @public (undocumented)
export interface ProjectionReferenceNode extends BaseNode {
    // (undocumented)
    readonly arguments: readonly Expression[];
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionReference;
    // (undocumented)
    readonly target: MemberExpressionNode | IdentifierNode;
}

// @public (undocumented)
export interface ProjectionRelationalExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionRelationalExpression;
    // (undocumented)
    readonly left: ProjectionExpression;
    // (undocumented)
    readonly op: "<=" | "<" | ">" | ">=";
    // (undocumented)
    readonly right: ProjectionExpression;
}

// @public (undocumented)
export type ProjectionStatementItem = ProjectionExpressionStatement;

// @public (undocumented)
export interface ProjectionStatementNode extends BaseNode, DeclarationNode {
    // (undocumented)
    readonly from?: ProjectionNode;
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionStatement;
    // (undocumented)
    readonly selector: ProjectionModelSelectorNode | ProjectionInterfaceSelectorNode | ProjectionOperationSelectorNode | ProjectionUnionSelectorNode | ProjectionEnumSelectorNode | MemberExpressionNode | IdentifierNode;
    // (undocumented)
    readonly to?: ProjectionNode;
}

// @public (undocumented)
export interface ProjectionTupleExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionTupleExpression;
    // (undocumented)
    readonly values: ProjectionExpression[];
}

// @public (undocumented)
export interface ProjectionType extends BaseType {
    // (undocumented)
    kind: "Projection";
    // (undocumented)
    node: undefined;
    // (undocumented)
    nodeByKind: Map<string, ProjectionStatementNode>;
    // (undocumented)
    nodeByType: Map<Type, ProjectionStatementNode>;
}

// @public (undocumented)
export interface ProjectionUnaryExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionUnaryExpression;
    // (undocumented)
    readonly op: "!";
    // (undocumented)
    readonly target: ProjectionExpression;
}

// @public (undocumented)
export interface ProjectionUnionSelectorNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.ProjectionUnionSelector;
}

// @public (undocumented)
export interface Projector {
    // (undocumented)
    projectedGlobalNamespace?: NamespaceType;
    // (undocumented)
    projectedStartNode?: Type;
    // (undocumented)
    projectedTypes: Map<Type, Type>;
    // (undocumented)
    projections: ProjectionApplication[];
    // (undocumented)
    projectType(type: Type): Type;
}

// @public
export function reducePathComponents(components: readonly string[]): string[];

// @public (undocumented)
export type ReferenceExpression = TypeReferenceNode | MemberExpressionNode | IdentifierNode | VoidKeywordNode | NeverKeywordNode;

// @public (undocumented)
export interface RemoveDirOptions {
    recursive?: boolean;
}

// @public
export function removeTrailingDirectorySeparator(path: string): string;

// @public
export function resolvePath(path: string, ...paths: (string | undefined)[]): string;

// @public (undocumented)
export interface ReturnExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.Return;
    // (undocumented)
    readonly value: ProjectionExpression;
}

// @public (undocumented)
export interface ReturnRecord {
    // (undocumented)
    kind: "Return";
    // (undocumented)
    value: Type;
}

// @public (undocumented)
export interface Scanner {
    eof(): boolean;
    readonly file: SourceFile;
    getTokenText(): string;
    getTokenValue(): string;
    readonly position: number;
    scan(): Token;
    readonly token: Token;
    readonly tokenPosition: number;
}

// @public (undocumented)
export type ScopeNode = NamespaceStatementNode | ModelStatementNode | InterfaceStatementNode | AliasStatementNode | CadlScriptNode | JsSourceFileNode | ProjectionLambdaExpressionNode | ProjectionNode;

// Warning: (ae-forgotten-export) The symbol "TypeListeners" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type SemanticNodeListener = {
    root?: (context: Program) => void;
} & TypeListeners;

// @public (undocumented)
export interface Server {
    // (undocumented)
    checkChange(change: TextDocumentChangeEvent<TextDocument>): Promise<void>;
    // (undocumented)
    complete(params: CompletionParams): Promise<CompletionList>;
    // (undocumented)
    documentClosed(change: TextDocumentChangeEvent<TextDocument>): void;
    // (undocumented)
    gotoDefinition(params: DefinitionParams): Promise<Location | undefined>;
    // (undocumented)
    initialize(params: InitializeParams): InitializeResult;
    // (undocumented)
    initialized(params: InitializedParams): void;
    // (undocumented)
    log(message: string, details?: any): void;
    // (undocumented)
    readonly pendingMessages: readonly string[];
    // (undocumented)
    watchedFilesChanged(params: DidChangeWatchedFilesParams): void;
    // (undocumented)
    readonly workspaceFolders: readonly ServerWorkspaceFolder[];
    // (undocumented)
    workspaceFoldersChanged(e: WorkspaceFoldersChangeEvent): void;
}

// @public (undocumented)
export interface ServerHost {
    // (undocumented)
    compilerHost: CompilerHost;
    // (undocumented)
    getDocumentByURL(url: string): TextDocument | undefined;
    // (undocumented)
    log(message: string): void;
    // (undocumented)
    sendDiagnostics(params: PublishDiagnosticsParams): void;
}

// @public (undocumented)
export interface ServerSourceFile extends SourceFile {
    // (undocumented)
    readonly document?: TextDocument;
}

// @public (undocumented)
export interface ServerWorkspaceFolder extends WorkspaceFolder {
    // (undocumented)
    path: string;
}

// @public (undocumented)
export function setDecoratorNamespace(namespace: string, ...decorators: DecoratorFunction[]): void;

// @public (undocumented)
export function setServiceHost(program: Program, host: string): void;

// @public (undocumented)
export function setServiceNamespace(program: Program, namespace: NamespaceType): void;

// @public (undocumented)
export function skipTrivia(input: string, position: number): number;

// @public (undocumented)
export interface SourceFile {
    getLineAndCharacterOfPosition(position: number): LineAndCharacter;
    getLineStarts(): readonly number[];
    readonly path: string;
    readonly text: string;
}

// @public (undocumented)
export interface SourceLocation extends TextRange {
    // (undocumented)
    file: SourceFile;
}

// @public (undocumented)
export type Statement = ImportStatementNode | ModelStatementNode | NamespaceStatementNode | InterfaceStatementNode | UnionStatementNode | UsingStatementNode | EnumStatementNode | AliasStatementNode | OperationStatementNode | EmptyStatementNode | InvalidStatementNode | ProjectionStatementNode;

// @public (undocumented)
export interface StringLiteralNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.StringLiteral;
    // (undocumented)
    readonly value: string;
}

// @public (undocumented)
export interface StringLiteralType extends BaseType {
    // (undocumented)
    kind: "String";
    // (undocumented)
    node?: StringLiteralNode;
    // (undocumented)
    value: string;
}

// @public (undocumented)
export interface SuppressDirective extends DirectiveBase {
    // (undocumented)
    code: string;
    // (undocumented)
    message: string;
    // (undocumented)
    name: "suppress";
}

// @public (undocumented)
export interface Sym {
    declarations: Node[];
    exports?: SymbolTable;
    // (undocumented)
    flags: SymbolFlags;
    id?: number;
    name: string;
    parent?: Sym;
    symbolSource?: Sym;
    value?: (...args: any[]) => any;
}

// @public (undocumented)
export const enum SymbolFlags {
    // (undocumented)
    Alias = 512,
    // (undocumented)
    Decorator = 4096,
    // (undocumented)
    DuplicateUsing = 262144,
    // (undocumented)
    Enum = 16,
    // (undocumented)
    EnumMember = 32,
    // (undocumented)
    ExportContainer = 525312,
    // (undocumented)
    Function = 32768,
    // (undocumented)
    FunctionParameter = 65536,
    // (undocumented)
    Interface = 64,
    // (undocumented)
    Model = 2,
    // (undocumented)
    ModelProperty = 4,
    // (undocumented)
    Namespace = 1024,
    // (undocumented)
    None = 0,
    // (undocumented)
    Operation = 8,
    // (undocumented)
    Projection = 2048,
    // (undocumented)
    ProjectionParameter = 16384,
    // (undocumented)
    SourceFile = 524288,
    // (undocumented)
    TemplateParameter = 8192,
    // (undocumented)
    Union = 128,
    // (undocumented)
    UnionVariant = 256,
    // (undocumented)
    Using = 131072
}

// @public (undocumented)
export interface SymbolLinks {
    // (undocumented)
    declaredType?: Type;
    // (undocumented)
    instantiations?: TypeInstantiationMap;
    // (undocumented)
    type?: Type;
}

// @public (undocumented)
export interface SymbolTable extends Map<string, Sym> {
    readonly duplicates: Map<Sym, Set<Sym>>;
}

// @public
export enum SyntaxKind {
    // (undocumented)
    AliasStatement = 19,
    // (undocumented)
    ArrayExpression = 23,
    // (undocumented)
    BlockComment = 35,
    // (undocumented)
    BooleanLiteral = 26,
    // (undocumented)
    CadlScript = 0,
    // (undocumented)
    DecoratorExpression = 4,
    // (undocumented)
    DirectiveExpression = 5,
    // (undocumented)
    EmptyStatement = 32,
    // (undocumented)
    EnumMember = 18,
    // (undocumented)
    EnumStatement = 17,
    // (undocumented)
    Identifier = 3,
    // (undocumented)
    ImportStatement = 2,
    // (undocumented)
    InterfaceStatement = 14,
    // (undocumented)
    IntersectionExpression = 21,
    // (undocumented)
    InvalidStatement = 33,
    // (undocumented)
    JsSourceFile = 1,
    // (undocumented)
    LineComment = 34,
    // (undocumented)
    MemberExpression = 6,
    // (undocumented)
    ModelExpression = 11,
    // (undocumented)
    ModelProperty = 12,
    // (undocumented)
    ModelSpreadProperty = 13,
    // (undocumented)
    ModelStatement = 10,
    // (undocumented)
    NamespaceStatement = 7,
    // (undocumented)
    NeverKeyword = 28,
    // (undocumented)
    NumericLiteral = 25,
    // (undocumented)
    OperationStatement = 9,
    // (undocumented)
    Projection = 36,
    // (undocumented)
    ProjectionArithmeticExpression = 51,
    // (undocumented)
    ProjectionBlockExpression = 45,
    // (undocumented)
    ProjectionCallExpression = 52,
    // (undocumented)
    ProjectionDecoratorReferenceExpression = 61,
    // (undocumented)
    ProjectionEnumSelector = 42,
    // (undocumented)
    ProjectionEqualityExpression = 48,
    // (undocumented)
    ProjectionExpressionStatement = 43,
    // (undocumented)
    ProjectionIfExpression = 44,
    // (undocumented)
    ProjectionInterfaceSelector = 41,
    // (undocumented)
    ProjectionLambdaExpression = 53,
    // (undocumented)
    ProjectionLambdaParameterDeclaration = 54,
    // (undocumented)
    ProjectionLogicalExpression = 47,
    // (undocumented)
    ProjectionMemberExpression = 46,
    // (undocumented)
    ProjectionModelExpression = 55,
    // (undocumented)
    ProjectionModelProperty = 56,
    // (undocumented)
    ProjectionModelSelector = 38,
    // (undocumented)
    ProjectionModelSpreadProperty = 57,
    // (undocumented)
    ProjectionOperationSelector = 39,
    // (undocumented)
    ProjectionParameterDeclaration = 37,
    // (undocumented)
    ProjectionReference = 30,
    // (undocumented)
    ProjectionRelationalExpression = 50,
    // (undocumented)
    ProjectionSpreadProperty = 58,
    // (undocumented)
    ProjectionStatement = 60,
    // (undocumented)
    ProjectionTupleExpression = 59,
    // (undocumented)
    ProjectionUnaryExpression = 49,
    // (undocumented)
    ProjectionUnionSelector = 40,
    // (undocumented)
    Return = 62,
    // (undocumented)
    StringLiteral = 24,
    // (undocumented)
    TemplateParameterDeclaration = 31,
    // (undocumented)
    TupleExpression = 22,
    // (undocumented)
    TypeReference = 29,
    // (undocumented)
    UnionExpression = 20,
    // (undocumented)
    UnionStatement = 15,
    // (undocumented)
    UnionVariant = 16,
    // (undocumented)
    UsingStatement = 8,
    // (undocumented)
    VoidKeyword = 27
}

// @public (undocumented)
export interface TemplateDeclarationNode {
    // (undocumented)
    locals?: SymbolTable;
    // (undocumented)
    readonly templateParameters: readonly TemplateParameterDeclarationNode[];
}

// @public (undocumented)
export interface TemplatedType {
    // (undocumented)
    templateArguments?: Type[];
    // (undocumented)
    templateNode?: Node;
}

// @public (undocumented)
export interface TemplateParameterDeclarationNode extends DeclarationNode, BaseNode {
    // (undocumented)
    readonly default?: Expression;
    // (undocumented)
    readonly kind: SyntaxKind.TemplateParameterDeclaration;
}

// @public (undocumented)
export interface TemplateParameterType extends BaseType {
    // (undocumented)
    default?: Type;
    // (undocumented)
    kind: "TemplateParameter";
    // (undocumented)
    node: TemplateParameterDeclarationNode;
}

// @public (undocumented)
export interface TextRange {
    end: number;
    pos: number;
}

// @public (undocumented)
export enum Token {
    // (undocumented)
    AliasKeyword = 49,
    // (undocumented)
    Ampersand = 23,
    // (undocumented)
    AmpsersandAmpersand = 37,
    // (undocumented)
    At = 28,
    // (undocumented)
    Bar = 24,
    // (undocumented)
    BarBar = 38,
    // (undocumented)
    CloseBrace = 11,
    // (undocumented)
    CloseBracket = 15,
    // (undocumented)
    CloseParen = 13,
    // (undocumented)
    Colon = 26,
    // (undocumented)
    ColonColon = 27,
    // (undocumented)
    Comma = 19,
    // (undocumented)
    ConflictMarker = 7,
    // (undocumented)
    Dot = 16,
    // (undocumented)
    Elipsis = 17,
    // (undocumented)
    ElseKeyword = 54,
    // (undocumented)
    EndOfFile = 2,
    // (undocumented)
    EnumKeyword = 48,
    // (undocumented)
    Equals = 22,
    // (undocumented)
    EqualsEquals = 39,
    // (undocumented)
    EqualsGreaterThan = 41,
    // (undocumented)
    Exclamation = 34,
    // (undocumented)
    ExclamationEquals = 40,
    // (undocumented)
    ExtendsKeyword = 56,
    // (undocumented)
    FalseKeyword = 58,
    // (undocumented)
    ForwardSlash = 31,
    // (undocumented)
    GreaterThan = 21,
    // (undocumented)
    GreaterThanEquals = 36,
    // (undocumented)
    Hash = 29,
    // (undocumented)
    Hyphen = 33,
    // (undocumented)
    Identifier = 42,
    // (undocumented)
    IfKeyword = 55,
    // (undocumented)
    ImportKeyword = 43,
    // (undocumented)
    InterfaceKeyword = 51,
    // (undocumented)
    Invalid = 1,
    // (undocumented)
    IsKeyword = 50,
    // (undocumented)
    LessThan = 20,
    // (undocumented)
    LessThanEquals = 35,
    // (undocumented)
    ModelKeyword = 44,
    // (undocumented)
    MultiLineComment = 4,
    // (undocumented)
    NamespaceKeyword = 45,
    // (undocumented)
    NeverKeyword = 61,
    // (undocumented)
    NewLine = 5,
    // (undocumented)
    None = 0,
    // (undocumented)
    NumericLiteral = 8,
    // (undocumented)
    OpenBrace = 10,
    // (undocumented)
    OpenBracket = 14,
    // (undocumented)
    OpenParen = 12,
    // (undocumented)
    OpKeyword = 47,
    // (undocumented)
    Plus = 32,
    // (undocumented)
    ProjectionKeyword = 53,
    // (undocumented)
    Question = 25,
    // (undocumented)
    ReturnKeyword = 59,
    // (undocumented)
    Semicolon = 18,
    // (undocumented)
    SingleLineComment = 3,
    // (undocumented)
    Star = 30,
    // (undocumented)
    StringLiteral = 9,
    // (undocumented)
    TrueKeyword = 57,
    // (undocumented)
    UnionKeyword = 52,
    // (undocumented)
    UsingKeyword = 46,
    // (undocumented)
    VoidKeyword = 60,
    // (undocumented)
    Whitespace = 6
}

// @public (undocumented)
export interface TupleExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.TupleExpression;
    // (undocumented)
    readonly values: readonly Expression[];
}

// @public (undocumented)
export interface TupleType extends BaseType {
    // (undocumented)
    kind: "Tuple";
    // (undocumented)
    node: TupleExpressionNode;
    // (undocumented)
    values: Type[];
}

// @public (undocumented)
export type Type = ModelType | ModelTypeProperty | InterfaceType | EnumType | EnumMemberType | TemplateParameterType | NamespaceType | OperationType | StringLiteralType | NumericLiteralType | BooleanLiteralType | ArrayType | TupleType | UnionType | UnionTypeVariant | IntrinsicType | FunctionType | ObjectType | ProjectionType;

// @public
export interface TypeInstantiationMap {
    // (undocumented)
    get(args: Type[]): Type | undefined;
    // (undocumented)
    set(args: Type[], type: Type): void;
}

// @public (undocumented)
export type TypeOfDiagnostics<T extends DiagnosticMap<any>> = T extends DiagnosticMap<infer D> ? D : never;

// @public (undocumented)
export type TypeOrReturnRecord = Type | ReturnRecord;

// @public (undocumented)
export interface TypeReferenceNode extends BaseNode {
    // (undocumented)
    arguments: Expression[];
    // (undocumented)
    kind: SyntaxKind.TypeReference;
    // (undocumented)
    target: MemberExpressionNode | IdentifierNode;
}

// @public (undocumented)
export interface UnionExpressionNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.UnionExpression;
    // (undocumented)
    readonly options: readonly Expression[];
}

// @public (undocumented)
export interface UnionStatementNode extends BaseNode, DeclarationNode, TemplateDeclarationNode {
    // (undocumented)
    readonly decorators: readonly DecoratorExpressionNode[];
    // (undocumented)
    readonly kind: SyntaxKind.UnionStatement;
    // (undocumented)
    readonly options: readonly UnionVariantNode[];
}

// @public (undocumented)
export interface UnionType extends BaseType, DecoratedType, TemplatedType {
    // (undocumented)
    expression: boolean;
    // (undocumented)
    kind: "Union";
    // (undocumented)
    name?: string;
    // (undocumented)
    namespace?: NamespaceType;
    // (undocumented)
    node: UnionExpressionNode | UnionStatementNode;
    // (undocumented)
    readonly options: Type[];
    // (undocumented)
    variants: Map<string | symbol, UnionTypeVariant>;
}

// @public (undocumented)
export interface UnionTypeVariant extends BaseType, DecoratedType {
    // (undocumented)
    kind: "UnionVariant";
    // (undocumented)
    name: string | symbol;
    // (undocumented)
    node: UnionVariantNode | undefined;
    // (undocumented)
    type: Type;
}

// @public (undocumented)
export interface UnionVariantNode extends BaseNode {
    // (undocumented)
    readonly decorators: readonly DecoratorExpressionNode[];
    // (undocumented)
    readonly id: IdentifierNode | StringLiteralNode;
    // (undocumented)
    readonly kind: SyntaxKind.UnionVariant;
    // (undocumented)
    readonly value: Expression;
}

// @public (undocumented)
export interface UsingStatementNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.UsingStatement;
    // (undocumented)
    readonly name: IdentifierNode | MemberExpressionNode;
}

// @public
export function validateDecoratorParamCount(program: Program, target: Type, args: unknown[], expected: number): void;

// @public
export function validateDecoratorParamType<K extends Type["kind"]>(program: Program, target: Type, value: CadlValue, expectedType: K | K[]): value is InferredCadlValue<K>;

// @public
export function validateDecoratorTarget<K extends Type["kind"]>(program: Program, target: Type, decoratorName: string, expectedType: K | K[]): target is Type & {
    kind: K;
};

// @public (undocumented)
export function validateDecoratorTargetIntrinsic(program: Program, target: ModelType | ModelTypeProperty, decoratorName: string, expectedType: IntrinsicModelName | IntrinsicModelName[]): boolean;

// Warning: (ae-forgotten-export) The symbol "NodeCb" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function visitChildren<T>(node: Node, cb: NodeCb<T>): T | undefined;

// @public (undocumented)
export interface VoidKeywordNode extends BaseNode {
    // (undocumented)
    readonly kind: SyntaxKind.VoidKeyword;
}

// @public (undocumented)
export interface VoidType extends IntrinsicType {
    // (undocumented)
    name: "void";
}

// @public
export type Writable<T> = {
    -readonly [P in keyof T]: T[P];
};

// @public (undocumented)
export type WriteLine = (text?: string) => void;

// (No @packageDocumentation comment for this package)

```
